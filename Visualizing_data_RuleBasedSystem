import os
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from wordcloud import WordCloud
import squarify
from sklearn.feature_extraction.text import ENGLISH_STOP_WORDS as STOPWORDS
import numpy as np

# Define the file path for the CSV file
csv_file_path = 'C:/Users/Danille/Desktop/Gebied_07/Vondsten/07_vondsten_lijst.csv'

# Load the CSV file into a DataFrame
df = pd.read_csv(csv_file_path, delimiter=';')

# Mapping of archaeological periods to date ranges (update as needed)
archaeological_periods_mapping = {
    'paleolithicum': 'everything until 8800 BC',
    'mesolithicum': '8800 BC - 5300 BC',
    'neolithicum': '5300 BC - 2000 BC',
    'vroege bronstijd': '2000 BC - 1800 BC',
    'midden bronstijd': '1800 BC - 1100 BC',
    'late brondstijd': '1100 BC - 800 BC',
    'vroege ijzertijd': '800 BC - 500 BC',
    'midden ijzertijd': '500 BC - 250 BC',
    'late ijzertijd': '250 BC - 12 BC',
    'vroeg romeinsetijd': '12 BC - 70 AD',
    'midden romeinsetijd': '70 AD - 270 AD',
    'laat romeinsetijd': '270 AD - 450 AD',
    'vroege middeleeuwen': '450 AD - 1050 AD',
    'late middeleeuwen': '1050 AD - 1500 AD',
    'vroege nieuwetijd': '1500 AD - 1650 AD',
    'midden nieuwetijd': '1650 AD - 1850 AD',
    'late nieuwetijd': '1850 AD - 1945 AD',
}

# Function to convert archaeological periods to date ranges
def convert_to_date_range(period):
    return archaeological_periods_mapping.get(period.lower(), period)

# Function to evaluate visualization quality
def evaluate_visualization_quality(ax, title):
    # Placeholder for color contrast calculation
    contrast_score = 0.8  # Replace with actual calculation
    
    # Placeholder for label readability check
    readable_labels = True  # Replace with actual check

    # Combine different quality metrics as needed
    overall_quality = contrast_score * 0.6 + readable_labels * 0.4

    # Set a threshold for acceptable quality
    threshold = 0.7
    if overall_quality >= threshold:
        plt.title(f'Quality: {overall_quality:.2f} - {title}')
        return True
    else:
        print(f"The visualization '{title}' did not meet the quality threshold.")
        return False

# Function to evaluate text overlap in WordCloud
def evaluate_text_overlap(wordcloud):
    # Placeholder for text overlap calculation
    overlap_percentage = 5  # Replace with actual calculation
    return overlap_percentage

# Function to analyze and categorize data columns
def analyze_data(data):
    categorical_cols = []
    numeric_cols = []
    cat_num_cols = []
    map_cols = []
    network_cols = []
    time_series_cols = []

    for col in data.columns:
        if 'datering' in col.lower() or 'date' in col.lower() or 'fase' in col.lower():
            time_series_cols.append(col)
            data[col] = data[col].apply(convert_to_date_range)
        elif data[col].dtype == 'O':
            categorical_cols.append(col)
        elif pd.api.types.is_numeric_dtype(data[col]):
            numeric_cols.append(col)

    return {
        'Categorical Columns': categorical_cols,
        'Numeric Columns': numeric_cols,
        'Categorical and Numeric Columns': cat_num_cols,
        'Map Columns': map_cols,
        'Network Columns': network_cols,
        'Time Series Columns': time_series_cols
    }

# Function to create visualizations for numeric columns
def create_numeric_visualizations(data, numeric_cols):
    for col in numeric_cols:
        if len(numeric_cols) == 1:
            # Histogram
            x_col = numeric_cols[0]
            plt.figure(figsize=(8, 6))
            sns.histplot(data[x_col], kde=True, bins=20)
            if evaluate_visualization_quality(plt.gca(), f'Histogram for {x_col}'):
                plt.show()

            # Density plot
            plt.figure(figsize=(8, 6))
            sns.kdeplot(data[x_col], fill=True)
            if evaluate_visualization_quality(plt.gca(), f'Density Plot for {x_col}'):
                plt.show()

        elif len(numeric_cols) == 2:
            # Violin Plot
            plt.figure(figsize=(8, 6))
            sns.violinplot(data=data[numeric_cols], inner="points", palette='viridis')
            if evaluate_visualization_quality(plt.gca(), f'Violinplot for {", ".join(numeric_cols)}'):
                plt.show()

            # Scatterplot with marginal points
            plt.figure(figsize=(8, 6))
            sns.scatterplot(x=numeric_cols[0], y=numeric_cols[1], data=data, hue=data[numeric_cols[0]], palette='viridis', legend='full', alpha=0.7)

            # Histogram
            sns.histplot(data[numeric_cols], kde=True, bins=20, element="step", fill=False, common_norm=False)
            if evaluate_visualization_quality(plt.gca(), f'Scatterplot with Marginal Points for {", ".join(numeric_cols)}'):
                plt.show()

        elif len(numeric_cols) >= 3:
            # Violinplot
            plt.figure(figsize=(8, 6))
            sns.violinplot(data=data[numeric_cols], inner="points", palette='viridis')
            if evaluate_visualization_quality(plt.gca(), f'Violinplot for {", ".join(numeric_cols)}'):
                plt.show()

            # Boxplot
            plt.figure(figsize=(8, 6))
            sns.boxplot(data=data[numeric_cols], palette='viridis')
            if evaluate_visualization_quality(plt.gca(), f'Boxplot for {", ".join(numeric_cols)}'):
                plt.show()

            # Stacked Area Plot
            plt.figure(figsize=(8, 6))
            sns.lineplot(data=data[numeric_cols].cumsum(axis=1))
            if evaluate_visualization_quality(plt.gca(), f'Stacked Area Plot for {", ".join(numeric_cols)}'):
                plt.show()

            # Streamgraph
            plt.figure(figsize=(8, 6))
            sns.lineplot(data=data[numeric_cols], dashes=False)
            if evaluate_visualization_quality(plt.gca(), f'Streamgraph for {", ".join(numeric_cols)}'):
                plt.show()

    plt.tight_layout()

# Create visualizations for numeric columns
numeric_data_categories = analyze_data(df)
create_numeric_visualizations(df, numeric_data_categories['Numeric Columns'])

# Function to create visualizations for categorical columns
def create_categoric_visualizations(data, categorical_cols):
    for col in categorical_cols:
        values = data[col].value_counts()
        if len(values) == 1:
            # Barplot
            plt.figure(figsize=(8, 6))
            sns.barplot(x=values.index, y=values)
            if evaluate_visualization_quality(plt.gca(), f'Barplot for {col}'):
                plt.show()
        elif len(values) == 2:
            # Lollipop plot
            plt.figure(figsize=(8, 6))
            sns.barplot(x=values.index, y=values)
            sns.scatterplot(x=values.index, y=values, color='red', marker='o', s=100)
            if evaluate_visualization_quality(plt.gca(), f'Lollipop Plot for {col}'):
                plt.show()
        elif len(values) > 2:
            # Wordcloud
            plt.figure(figsize=(8, 8))
            wordcloud = WordCloud(width=800, height=800, background_color='white').generate_from_frequencies(values)

            # Evaluate text overlap
            overlap_score = evaluate_text_overlap(wordcloud)

            # Display the wordcloud if overlap is below a threshold and general quality is acceptable
            if overlap_score < 10 and evaluate_visualization_quality(plt.gca(), f'Wordcloud for {col}'):
                plt.imshow(wordcloud, interpolation='bilinear')
                plt.axis('off')
                plt.show()

            # ... (Other categorical visualizations)

    plt.tight_layout()

# Create visualizations for categorical columns
categoric_data_categories = analyze_data(df)
create_categoric_visualizations(df, categoric_data_categories['Categorical Columns'])
